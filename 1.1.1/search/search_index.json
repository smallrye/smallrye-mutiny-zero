{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Mutiny Zero is a minimal API for creating reactive streams compliant publishers.</p> <p>It weights less than 50K and has 0 external dependency as it uses the Java Flow APIs).</p>"},{"location":"#what-are-reactive-streams","title":"What are reactive streams?","text":"<p>From the reactive streams website:</p> <p>Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure.</p> <p>Reactive streams are the lingua franca for an open and vendor-neutral asynchronous programming ecosystem in Java.</p> <p>In a reactive streams ecosystem sources with asynchronous I/O can be wrapped as publishers, and applications can subscribe to these publishers:</p> <p></p> <p>Since reactive streams are defined as a set of minimal interfaces (see the Java Flow interfaces), it is possible to mix and match publishers, processors and subscribers from different software stacks. For instance an event streaming service and a large data store can expose reactive streams compliant clients. In turn applications can be made end-to-end reactive as long as the code honors reactive streams protocols and semantics.</p> <p>Reactive streams is a low-level protocol and applications shall use higher-level reactive programming libraries such as Mutiny.</p>"},{"location":"#why-is-mutiny-zero-any-needed","title":"Why is Mutiny Zero any needed?","text":"<p>The reactive streams interfaces are quite simple, so where is the catch?</p>"},{"location":"#its-all-about-the-protocol","title":"It\u2019s all about the protocol!","text":"<p>In a perfect world middleware and service vendors would simply implement these interfaces and ship client libraries. The problem with reactive streams is not the interfaces: the protocol is the hard part.</p> <p>Reactive streams come with a specification and a TCK to check for publishers, processors and subscribers conformance. There are many subtle rules that the TCK verifies, and it can be surprisingly hard to respect all of them.</p> <p>Of course one may be tempted to just ignore some rules and just focus on the Java interfaces, but then combining reactive bits will likely break at runtime due to back-pressure and/or threading problems.</p>"},{"location":"#why-does-it-matter-to-keep-the-ecosystem-open-and-vendor-neutral","title":"Why does it matter to keep the ecosystem open and vendor-neutral?","text":"<p>Developing reactive streams compliant libraries is difficult, so vendors have been tempted to simply reuse a high-level reactive programming library.</p> <p>All of these libraries have ways to create publishers from different eventing models, and because they are supposed to pass the reactive streams TCK then the resulting publishers shall also be compliant. This is a technically correct yet a poor answer in our opinion.</p> <p></p> <p>We dived into the code of several reactive streams client libraries, and we found out that more often than not they had become tightly-coupled to the peculiarities of certain reactive programming libraries.</p> <p>This is a major problem because strong adherence to a complete reactive programming library annihilates the benefits of the reactive streams specification:</p> <ul> <li>applications may want to use a different reactive programming library than the one chosen by a vendor, bringing unwanted dependencies (who needs 3 reactive programming libraries in their code base?), </li> <li>vendors become bound to the release cycle of the chosen reactive programming library,</li> <li>conflicts between versions are more likely to happen because different vendors may depend on incompatible versions of a given reactive programming library.</li> </ul>"},{"location":"#the-promise-of-mutiny-zero","title":"The promise of Mutiny Zero","text":"<p>The mission of Mutiny Zero is to provide a minimal library for implementing reactive streams compliant publishers.</p> <p></p> <p>Mutiny Zero does not want to be a complete reactive programming library for Java, so you will only find APIs and helpers deemed useful to write publishers. Nothing else, nothing more.</p> <p>Application developers must be free to choose their reactive stacks and not be imposed opinionated choices by vendors! </p>"},{"location":"flow-adapters/","title":"JDK Flow from/to Reactive Streams Adapters","text":"<p>The <code>mutiny-zero-flow-adapters</code> library (Maven coordinates <code>io.smallrye.reactive:mutiny-zero-flow-adapters</code>) provides a clean room implementation of adapters from and to the JDK Flow interfaces that match those from Reactive Streams.</p>"},{"location":"flow-adapters/#why-another-adapter-library","title":"Why another adapter library?","text":"<p>The implementation of our adapters is similar in spirit to those from the Reactive Streams library, but they differ by:</p> <ul> <li>failing early rather than passing <code>null</code> through in some cases,</li> <li>shipping under a proper open source license while the Reactive Streams library took a long time to make any progress towards publishing a new release, see #536 and #530 </li> <li>having correct JPMS (Java modules) descriptors for those who might need modules rather than the classpath.</li> </ul>"},{"location":"flow-adapters/#how-to-use-it","title":"How to use it?","text":"<p>The public API exposes 2 types:</p> <ul> <li><code>AdaptersToFlow</code> to convert Reactive Streams types to <code>Flow</code> types, and</li> <li><code>AdaptersToReactiveStreams</code> to convert <code>Flow</code> types to Reactive Streams types.</li> </ul> <p>Each type offers factory methods to convert from one type to the other. For instance here\u2019s how you can convert from a Reactive Streams <code>Publisher</code> to a <code>Flow.Publisher</code>:</p> <pre><code>Publisher&lt;String&gt; rsPublisher = connect(\"foo\"); // ... where 'connect' returns a Publisher&lt;String&gt;\n\nFlow.Publisher&lt;String&gt; flowPublisher = AdaptersToFlow.publisher(rsPublisher);\n</code></pre>"},{"location":"quick-start/","title":"Quick start","text":""},{"location":"quick-start/#getting-mutiny-zero","title":"Getting Mutiny Zero","text":"<p>You can get Mutiny Zero through the following Maven coordinates:</p> <ul> <li><code>groupId</code>: <code>io.smallrye.reactive</code></li> <li><code>artifactId</code>: <code>mutiny-zero</code></li> </ul> <p>Mutiny Zero exposes publishers (see <code>java.util.concurrent.Flow</code>).</p>"},{"location":"quick-start/#creating-publishers","title":"Creating publishers","text":"<p>Your main entry point in the Mutiny Zero API is the <code>mutiny.zero.ZeroPublisher</code> interface that exposes factory methods.</p>"},{"location":"quick-start/#creating-from-known-values","title":"Creating from known values","text":"<p>If you already know the values to be emitted (or a failure), then you can use following factory methods:</p> <pre><code>package docsamples;\n\nimport static mutiny.zero.ZeroPublisher.*;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.concurrent.Flow.Publisher;\n\npublic class FromKnownValues {\n\n    public static void main(String[] args) {\n\n        // From values\n        Publisher&lt;Integer&gt; pub1 = fromItems(1, 2, 3);\n\n        // From an iterable\n        Publisher&lt;Integer&gt; pub2 = fromIterable(Arrays.asList(1, 2, 3));\n\n        // From a failure\n        Publisher&lt;?&gt; pub3 = fromFailure(new IOException(\"Broken pipe\"));\n    }\n}\n</code></pre>"},{"location":"quick-start/#creating-from-completionstage","title":"Creating from <code>CompletionStage</code>","text":"<p><code>CompletionStage</code> is the Java SDK API for asynchronous operations that emit either a result or a failure.</p> <p>Mutiny Zero can create a <code>Publisher</code> from a <code>CompletionStage</code> that emits exactly 1 item or a failure, then a completion signal:</p> <pre><code>package docsamples;\n\nimport static java.util.concurrent.CompletableFuture.supplyAsync;\nimport static mutiny.zero.ZeroPublisher.fromCompletionStage;\n\nimport java.util.concurrent.Flow;\n\npublic class FromCompletionStage {\n\n    public static void main(String[] args) {\n\n        Flow.Publisher&lt;Long&gt; pun = fromCompletionStage(() -&gt; supplyAsync(() -&gt; 58L));\n    }\n}\n</code></pre>"},{"location":"quick-start/#creating-using-the-general-purpose-tube-api","title":"Creating using the general-purpose <code>Tube</code> API","text":"<p>For all other cases you should use the <code>mutiny.zero.Tube</code> API.</p> <p>A <code>Tube</code> represents an object you can interact with to emit values, error and completion. It is aware of cancellation and items requests made by the subscriber.</p> <p>A <code>Tube</code> is a good abstraction if you want to pass events from an existing asynchronous I/O source as they arrive. Here is a not so fictional example where <code>SampleAsyncSource</code> (an asynchronous I/O API) has to be adapted to a <code>Publisher</code>:</p> <pre><code>package docsamples;\n\nimport static mutiny.zero.ZeroPublisher.create;\n\nimport java.util.concurrent.Flow.Publisher;\n\nimport mutiny.zero.BackpressureStrategy;\nimport mutiny.zero.TubeConfiguration;\n\npublic class FromTube {\n\n    public static void main(String[] args) {\n\n        SampleAsyncSource source = new SampleAsyncSource();\n\n        TubeConfiguration configuration = new TubeConfiguration()\n                .withBackpressureStrategy(BackpressureStrategy.BUFFER)\n                .withBufferSize(256);\n\n        Publisher&lt;String&gt; pub = create(configuration, tube -&gt; {\n\n            // Start\n            source.start();\n\n            // Allow items to be received\n            tube.whenRequested(n -&gt; source.resume());\n\n            // Termination cases\n            tube.whenCancelled(source::close);\n            tube.whenTerminates(() -&gt; System.out.println(\"Done\"));\n\n            // Emit items, pause the source if need be\n            source.onItem(str -&gt; {\n                tube.send(str);\n                if (tube.outstandingRequests() == 0L) {\n                    source.pause();\n                }\n            });\n\n            // Error\n            source.onError(tube::fail);\n\n            // Completion\n            source.onEnd(tube::complete);\n\n        });\n    }\n}\n</code></pre> <p>Since <code>SampleAsyncSource</code> does not support reactive streams but can be paused and resumed, the <code>Tube</code> API is used not just to send items but also to control <code>SampleAsyncSource</code>. The <code>Tube</code> also has a buffer of 256 items in case of overflow to cope with the fact that pausing <code>SampleAsyncSource</code> may not be immediate.</p> <p>Several back-pressure strategies are offered by <code>Tube</code>:</p> <ul> <li>buffer items (with or without a bound),</li> <li>drop items,</li> <li>signal an error,</li> <li>ignore back-pressure and still send items,</li> <li>keep only the last values in a fixed-size buffer.</li> </ul> <p><code>Tube</code> enforces the reactive streams protocol. For instance if you have several threads competing to send items, then items will still be emitted serially by one of the threads rather than concurrently.</p>"},{"location":"quick-start/#helpers","title":"Helpers","text":"<p>Mutiny Zero offers a few helpers for commonly-needed tasks, but without the intention of becoming a full-fledge reactive programming API.</p> <p>Introducing new helpers will always be done carefully by observing real world implementation patterns.</p>"},{"location":"quick-start/#completionstage-helpers","title":"<code>CompletionStage</code> helpers","text":"<p>The <code>AsyncHelpers</code> class offers a few helpers to simplify developing against the <code>CompletionStage</code>, especially before Java 11.</p> <ul> <li><code>applyExceptionally</code> applies a function to map a failure <code>Throwable</code> to another <code>Throwable</code>.</li> <li><code>composeExceptionally</code> applies a function to compose a failure <code>Throwable</code> to another <code>CompletionStage</code>.</li> </ul>"},{"location":"quick-start/#publisher-helpers","title":"<code>Publisher</code> helpers","text":"<p>More often than not we need a little help when dealing with a <code>Publisher</code>.</p> <ul> <li><code>collectToList</code> assembles all items from a <code>Publisher</code> to a <code>CompletionStage&lt;List&gt;</code>. </li> </ul>"},{"location":"vertx-based-reactive-streams-publishers/","title":"Vert.x-based Reactive Streams Publishers","text":"<p>The <code>mutiny-zero-vertx-publishers</code> library (Maven coordinates <code>io.smallrye.reactive:mutiny-zero-vertx-publishers</code>) allows creating Reactive Streams publishers from Vert.x streams.</p> <p>This library acts as a thin adapter between Vert.x <code>ReadStream</code> and <code>java.util.concurrent.Flow.Publisher</code> and uses Mutiny Zero to expose Reactive Streams compliant publishers.</p>"},{"location":"vertx-based-reactive-streams-publishers/#api-overview","title":"API overview","text":"<p>The entry point is the <code>mutiny.zero.vertxpublishers.VertxPublisher</code> interface that exposes 2 static factory methods.</p> <ul> <li><code>Publisher&lt;T&gt; fromSupplier(Supplier&lt;ReadStream&lt;T&gt;&gt; streamSupplier)</code> is to be used when some Vert.x API returns a <code>ReadStream&lt;T&gt;</code>.</li> <li><code>Publisher&lt;T&gt; fromFuture(Supplier&lt;Future&lt;? extends ReadStream&lt;T&gt;&gt;&gt; futureStreamSupplier)</code> is to be used when some Vert.x API asynchronously returns a <code>ReadStream&lt;T&gt;</code> through a <code>Future</code>.</li> </ul> <p>The factory methods use suppliers so that the <code>ReadStream</code> instances to be adapted are on a per-subscriber basis.</p>"},{"location":"vertx-based-reactive-streams-publishers/#sample-usage","title":"Sample usage","text":"<p>The following example makes HTTP requests to the Newcastle University Urban Observatory API using the Vert.x HTTP client:</p> <pre><code>package docsamples;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Flow;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\nimport io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.http.HttpClient;\nimport io.vertx.core.http.HttpClientRequest;\nimport io.vertx.core.http.HttpMethod;\nimport io.vertx.core.http.RequestOptions;\nimport mutiny.zero.vertxpublishers.VertxPublisher;\n\npublic class UrbanObservatoryHttpClient {\n\n    public static void main(String[] args) {\n\n        Vertx vertx = Vertx.vertx();\n        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n\n        RequestOptions opts = new RequestOptions()\n                .setSsl(true)\n                .setHost(\"api.usb.urbanobservatory.ac.uk\")\n                .setPort(443)\n                .setMethod(HttpMethod.GET)\n                .addHeader(\"Accept\", \"application/json\")\n                .setURI(\"/api/v2.0a/sensors/entity\");\n\n        HttpClient httpClient = vertx.createHttpClient();\n\n        Flow.Publisher&lt;Buffer&gt; publisher = VertxPublisher.fromFuture(() -&gt; httpClient\n                .request(opts)\n                .compose(HttpClientRequest::send));\n\n        publisher.subscribe(new Flow.Subscriber&lt;&gt;() {\n\n            private Flow.Subscription subscription;\n\n            @Override\n            public void onSubscribe(Flow.Subscription s) {\n                System.out.println(\"======================================\");\n                this.subscription = s;\n                s.request(1L);\n            }\n\n            @Override\n            public void onNext(Buffer buffer) {\n                System.out.print(buffer.toString(StandardCharsets.UTF_8));\n                executor.schedule(() -&gt; subscription.request(1L), 500, TimeUnit.MILLISECONDS);\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                System.out.println(\"======================================\");\n                t.printStackTrace();\n            }\n\n            @Override\n            public void onComplete() {\n                System.out.println(\"======================================\");\n            }\n        });\n    }\n}\n</code></pre> <p>A new HTTP connection is issued everytime the publisher is being subscribed. In this example the subscriber controls demand by requesting a new Vert.x <code>Buffer</code> every 500ms.</p> <p>If you run this program then you will see the JSON response being progressively printed to the standard console in chunks, every 500 milliseconds.  </p>"},{"location":"apidocs/legal/jquery/","title":"Jquery","text":""},{"location":"apidocs/legal/jquery/#jquery-v371","title":"jQuery v3.7.1","text":""},{"location":"apidocs/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.7.1\nCopyright OpenJS Foundation and other contributors, https://openjsf.org/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"apidocs/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"apidocs/legal/jqueryUI/#jquery-ui-v1132","title":"jQuery UI v1.13.2","text":""},{"location":"apidocs/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"}]}