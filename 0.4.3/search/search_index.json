{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Mutiny Zero is a minimal API for creating reactive streams compliant publishers. It weights less than 50K and has 0 external dependency beyond the reactive streams API (or Java Flow ). What are reactive streams? From the reactive streams website : Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. Reactive streams are the lingua franca for an open and vendor-neutral asynchronous programming ecosystem in Java. In a reactive streams ecosystem sources with asynchronous I/O can be wrapped as publishers , and applications can subscribe to these publishers: Since reactive streams are defined as a set of minimal interfaces (see the Java Flow interfaces ), it is possible to mix and match publishers, processors and subscribers from different software stacks. For instance an event streaming service and a large data store can expose reactive streams compliant clients. In turn applications can be made end-to-end reactive as long as the code honors reactive streams protocols and semantics. Reactive streams is a low-level protocol and applications shall use higher-level reactive programming libraries such as Mutiny . Why is Mutiny Zero any needed? The reactive streams interfaces are quite simple, so where is the catch? It's all about the protocol! In a perfect world middleware and service vendors would simply implement these interfaces and ship client libraries. The problem with reactive streams is not the interfaces: the protocol is the hard part. Reactive streams come with a specification and a TCK to check for publishers, processors and subscribers conformance . There are many subtle rules that the TCK verifies, and it can be surprisingly hard to respect all of them. Of course one may be tempted to just ignore some rules and just focus on the Java interfaces, but then combining reactive bits will likely break at runtime due to back-pressure and/or threading problems. Why does it matter to keep the ecosystem open and vendor-neutral? Developing reactive streams compliant libraries is difficult, so vendors have been tempted to simply reuse a high-level reactive programming library. All of these libraries have ways to create publishers from different eventing models, and because they are supposed to pass the reactive streams TCK then the resulting publishers shall also be compliant. This is a technically correct yet a poor answer in our opinion. We dived into the code of several reactive streams client libraries, and we found out that more often than not they had become tightly-coupled to the peculiarities of certain reactive programming libraries. This is a major problem because strong adherence to a complete reactive programming library annihilates the benefits of the reactive streams specification: applications may want to use a different reactive programming library than the one chosen by a vendor, bringing unwanted dependencies (who needs 3 reactive programming libraries in their code base?), vendors become bound to the release cycle of the chosen reactive programming library, conflicts between versions are more likely to happen because different vendors may depend on incompatible versions of a given reactive programming library. The promise of Mutiny Zero The mission of Mutiny Zero is to provide a minimal library for implementing reactive streams compliant publishers. Mutiny Zero does not want to be a complete reactive programming library for Java, so you will only find APIs and helpers deemed useful to write publishers. Nothing else, nothing more. Application developers must be free to choose their reactive stacks and not be imposed opinionated choices by vendors!","title":"Overview"},{"location":"#overview","text":"Mutiny Zero is a minimal API for creating reactive streams compliant publishers. It weights less than 50K and has 0 external dependency beyond the reactive streams API (or Java Flow ).","title":"Overview"},{"location":"#what-are-reactive-streams","text":"From the reactive streams website : Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. Reactive streams are the lingua franca for an open and vendor-neutral asynchronous programming ecosystem in Java. In a reactive streams ecosystem sources with asynchronous I/O can be wrapped as publishers , and applications can subscribe to these publishers: Since reactive streams are defined as a set of minimal interfaces (see the Java Flow interfaces ), it is possible to mix and match publishers, processors and subscribers from different software stacks. For instance an event streaming service and a large data store can expose reactive streams compliant clients. In turn applications can be made end-to-end reactive as long as the code honors reactive streams protocols and semantics. Reactive streams is a low-level protocol and applications shall use higher-level reactive programming libraries such as Mutiny .","title":"What are reactive streams?"},{"location":"#why-is-mutiny-zero-any-needed","text":"The reactive streams interfaces are quite simple, so where is the catch?","title":"Why is Mutiny Zero any needed?"},{"location":"#its-all-about-the-protocol","text":"In a perfect world middleware and service vendors would simply implement these interfaces and ship client libraries. The problem with reactive streams is not the interfaces: the protocol is the hard part. Reactive streams come with a specification and a TCK to check for publishers, processors and subscribers conformance . There are many subtle rules that the TCK verifies, and it can be surprisingly hard to respect all of them. Of course one may be tempted to just ignore some rules and just focus on the Java interfaces, but then combining reactive bits will likely break at runtime due to back-pressure and/or threading problems.","title":"It's all about the protocol!"},{"location":"#why-does-it-matter-to-keep-the-ecosystem-open-and-vendor-neutral","text":"Developing reactive streams compliant libraries is difficult, so vendors have been tempted to simply reuse a high-level reactive programming library. All of these libraries have ways to create publishers from different eventing models, and because they are supposed to pass the reactive streams TCK then the resulting publishers shall also be compliant. This is a technically correct yet a poor answer in our opinion. We dived into the code of several reactive streams client libraries, and we found out that more often than not they had become tightly-coupled to the peculiarities of certain reactive programming libraries. This is a major problem because strong adherence to a complete reactive programming library annihilates the benefits of the reactive streams specification: applications may want to use a different reactive programming library than the one chosen by a vendor, bringing unwanted dependencies (who needs 3 reactive programming libraries in their code base?), vendors become bound to the release cycle of the chosen reactive programming library, conflicts between versions are more likely to happen because different vendors may depend on incompatible versions of a given reactive programming library.","title":"Why does it matter to keep the ecosystem open and vendor-neutral?"},{"location":"#the-promise-of-mutiny-zero","text":"The mission of Mutiny Zero is to provide a minimal library for implementing reactive streams compliant publishers. Mutiny Zero does not want to be a complete reactive programming library for Java, so you will only find APIs and helpers deemed useful to write publishers. Nothing else, nothing more. Application developers must be free to choose their reactive stacks and not be imposed opinionated choices by vendors!","title":"The promise of Mutiny Zero"},{"location":"flow-adapters/","text":"JDK Flow from/to Reactive Streams Adapters The mutiny-zero-flow-adapters library (Maven coordinates io.smallrye.reactive:mutiny-zero-flow-adapters ) provides a clean room implementation of adapters from and to the JDK Flow interfaces that match those from Reactive Streams. Why another adapter library? The implementation of our adapters is similar in spirit to those from the Reactive Streams library , but they differ by: failing early rather than passing null through in some cases, shipping under a proper open source license while the Reactive Streams library hasn't made any progress towards publishing a new release, see #536 and #530 having correct JPMS (Java modules) descriptors for those who might need modules rather than the classpath. How to use it? The public API exposes 2 types: AdaptersToFlow to convert Reactive Streams types to Flow types, and AdaptersToReactiveStreams to convert Flow types to Reactive Streams types. Each type offers factory methods to convert from one type to the other. For instance here's how you can convert from a Reactive Streams Publisher to a Flow.Publisher : Publisher < String > rsPublisher = connect ( \"foo\" ); // ... where 'connect' returns a Publisher<String> Flow . Publisher < String > flowPublisher = AdaptersToFlow . publisher ( rsPublisher );","title":"JDK Flow from/to Reactive Streams Adapters"},{"location":"flow-adapters/#jdk-flow-fromto-reactive-streams-adapters","text":"The mutiny-zero-flow-adapters library (Maven coordinates io.smallrye.reactive:mutiny-zero-flow-adapters ) provides a clean room implementation of adapters from and to the JDK Flow interfaces that match those from Reactive Streams.","title":"JDK Flow from/to Reactive Streams Adapters"},{"location":"flow-adapters/#why-another-adapter-library","text":"The implementation of our adapters is similar in spirit to those from the Reactive Streams library , but they differ by: failing early rather than passing null through in some cases, shipping under a proper open source license while the Reactive Streams library hasn't made any progress towards publishing a new release, see #536 and #530 having correct JPMS (Java modules) descriptors for those who might need modules rather than the classpath.","title":"Why another adapter library?"},{"location":"flow-adapters/#how-to-use-it","text":"The public API exposes 2 types: AdaptersToFlow to convert Reactive Streams types to Flow types, and AdaptersToReactiveStreams to convert Flow types to Reactive Streams types. Each type offers factory methods to convert from one type to the other. For instance here's how you can convert from a Reactive Streams Publisher to a Flow.Publisher : Publisher < String > rsPublisher = connect ( \"foo\" ); // ... where 'connect' returns a Publisher<String> Flow . Publisher < String > flowPublisher = AdaptersToFlow . publisher ( rsPublisher );","title":"How to use it?"},{"location":"quick-start/","text":"Quick start Getting Mutiny Zero You can get Mutiny Zero through the following Maven coordinates: groupId : io.smallrye.reactive artifactId : mutiny-zero Mutiny Zero exposes publishers from the reactive streams library. If you are interested in exposing JDK Flow publishers then you can use the jdk-flow classifier which is free from any dependency to the reactive streams library. Creating publishers Your main entry point in the Mutiny Zero API is the mutiny.zero.ZeroPublisher interface that exposes factory methods. Creating from known values If you already know the values to be emitted (or a failure), then you can use following factory methods: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package docsamples ; import static mutiny.zero.ZeroPublisher.* ; import java.io.IOException ; import java.util.Arrays ; import org.reactivestreams.Publisher ; public class FromKnownValues { public static void main ( String [] args ) { // From values Publisher < Integer > pub1 = fromItems ( 1 , 2 , 3 ); // From an iterable Publisher < Integer > pub2 = fromIterable ( Arrays . asList ( 1 , 2 , 3 )); // From a failure Publisher <?> pub3 = fromFailure ( new IOException ( \"Broken pipe\" )); } } Creating from CompletionStage CompletionStage is the Java SDK API for asynchronous operations that emit either a result or a failure. Mutiny Zero can create a Publisher from a CompletionStage that emits exactly 1 item or a failure, then a completion signal: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package docsamples ; import static java.util.concurrent.CompletableFuture.supplyAsync ; import static mutiny.zero.ZeroPublisher.fromCompletionStage ; import org.reactivestreams.Publisher ; public class FromCompletionStage { public static void main ( String [] args ) { Publisher < Long > pun = fromCompletionStage (() -> supplyAsync (() -> 58L )); } } Creating using the general-purpose Tube API For all other cases you should use the mutiny.zero.Tube API. A Tube represents an object you can interact with to emit values, error and completion. It is aware of cancellation and items requests made by the subscriber. A Tube is a good abstraction if you want to pass events from an existing asynchronous I/O source as they arrive. Here is a not so fictional example where SampleAsyncSource (an asynchronous I/O API) has to be adapted to a Publisher : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package docsamples ; import static mutiny.zero.ZeroPublisher.create ; import org.reactivestreams.Publisher ; import mutiny.zero.BackpressureStrategy ; import mutiny.zero.TubeConfiguration ; public class FromTube { public static void main ( String [] args ) { SampleAsyncSource source = new SampleAsyncSource (); TubeConfiguration configuration = new TubeConfiguration () . withBackpressureStrategy ( BackpressureStrategy . BUFFER ) . withBufferSize ( 256 ); Publisher < String > pub = create ( configuration , tube -> { // Start source . start (); // Allow items to be received tube . whenRequested ( n -> source . resume ()); // Termination cases tube . whenCancelled ( source :: close ); tube . whenTerminates (() -> System . out . println ( \"Done\" )); // Emit items, pause the source if need be source . onItem ( str -> { tube . send ( str ); if ( tube . outstandingRequests () == 0 L ) { source . pause (); } }); // Error source . onError ( tube :: fail ); // Completion source . onEnd ( tube :: complete ); }); } } Since SampleAsyncSource does not support reactive streams but can be paused and resumed, the Tube API is used not just to send items but also to control SampleAsyncSource . The Tube also has a buffer of 256 items in case of overflow to cope with the fact that pausing SampleAsyncSource may not be immediate. Several back-pressure strategies are offered by Tube : buffer items (with or without a bound), drop items, signal an error, ignore back-pressure and still send items, keep only the last values in a fixed-size buffer. Tube enforces the reactive streams protocol. For instance if you have several threads competing to send items, then items will still be emitted serially by one of the threads rather than concurrently. Helpers Mutiny Zero offers a few helpers for commonly-needed tasks, but without the intention of becoming a full-fledge reactive programming API. Introducing new helpers will always be done carefully by observing real world implementation patterns. CompletionStage helpers The AsyncHelpers class offers a few helpers to simplify developing against the CompletionStage , especially before Java 11. failedFuture creates a CompletionStage that has already failed. applyExceptionally applies a function to map a failure Throwable to another Throwable . composeExceptionally applies a function to compose a failure Throwable to another CompletionStage . Publisher helpers More often than not we need a little help when dealing with a Publisher . collectToList assembles all items from a Publisher to a CompletionStage<List> . map returns a Publisher that applies a function to all items from the original Publisher .","title":"Quick start"},{"location":"quick-start/#quick-start","text":"","title":"Quick start"},{"location":"quick-start/#getting-mutiny-zero","text":"You can get Mutiny Zero through the following Maven coordinates: groupId : io.smallrye.reactive artifactId : mutiny-zero Mutiny Zero exposes publishers from the reactive streams library. If you are interested in exposing JDK Flow publishers then you can use the jdk-flow classifier which is free from any dependency to the reactive streams library.","title":"Getting Mutiny Zero"},{"location":"quick-start/#creating-publishers","text":"Your main entry point in the Mutiny Zero API is the mutiny.zero.ZeroPublisher interface that exposes factory methods.","title":"Creating publishers"},{"location":"quick-start/#creating-from-known-values","text":"If you already know the values to be emitted (or a failure), then you can use following factory methods: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package docsamples ; import static mutiny.zero.ZeroPublisher.* ; import java.io.IOException ; import java.util.Arrays ; import org.reactivestreams.Publisher ; public class FromKnownValues { public static void main ( String [] args ) { // From values Publisher < Integer > pub1 = fromItems ( 1 , 2 , 3 ); // From an iterable Publisher < Integer > pub2 = fromIterable ( Arrays . asList ( 1 , 2 , 3 )); // From a failure Publisher <?> pub3 = fromFailure ( new IOException ( \"Broken pipe\" )); } }","title":"Creating from known values"},{"location":"quick-start/#creating-from-completionstage","text":"CompletionStage is the Java SDK API for asynchronous operations that emit either a result or a failure. Mutiny Zero can create a Publisher from a CompletionStage that emits exactly 1 item or a failure, then a completion signal: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package docsamples ; import static java.util.concurrent.CompletableFuture.supplyAsync ; import static mutiny.zero.ZeroPublisher.fromCompletionStage ; import org.reactivestreams.Publisher ; public class FromCompletionStage { public static void main ( String [] args ) { Publisher < Long > pun = fromCompletionStage (() -> supplyAsync (() -> 58L )); } }","title":"Creating from CompletionStage"},{"location":"quick-start/#creating-using-the-general-purpose-tube-api","text":"For all other cases you should use the mutiny.zero.Tube API. A Tube represents an object you can interact with to emit values, error and completion. It is aware of cancellation and items requests made by the subscriber. A Tube is a good abstraction if you want to pass events from an existing asynchronous I/O source as they arrive. Here is a not so fictional example where SampleAsyncSource (an asynchronous I/O API) has to be adapted to a Publisher : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package docsamples ; import static mutiny.zero.ZeroPublisher.create ; import org.reactivestreams.Publisher ; import mutiny.zero.BackpressureStrategy ; import mutiny.zero.TubeConfiguration ; public class FromTube { public static void main ( String [] args ) { SampleAsyncSource source = new SampleAsyncSource (); TubeConfiguration configuration = new TubeConfiguration () . withBackpressureStrategy ( BackpressureStrategy . BUFFER ) . withBufferSize ( 256 ); Publisher < String > pub = create ( configuration , tube -> { // Start source . start (); // Allow items to be received tube . whenRequested ( n -> source . resume ()); // Termination cases tube . whenCancelled ( source :: close ); tube . whenTerminates (() -> System . out . println ( \"Done\" )); // Emit items, pause the source if need be source . onItem ( str -> { tube . send ( str ); if ( tube . outstandingRequests () == 0 L ) { source . pause (); } }); // Error source . onError ( tube :: fail ); // Completion source . onEnd ( tube :: complete ); }); } } Since SampleAsyncSource does not support reactive streams but can be paused and resumed, the Tube API is used not just to send items but also to control SampleAsyncSource . The Tube also has a buffer of 256 items in case of overflow to cope with the fact that pausing SampleAsyncSource may not be immediate. Several back-pressure strategies are offered by Tube : buffer items (with or without a bound), drop items, signal an error, ignore back-pressure and still send items, keep only the last values in a fixed-size buffer. Tube enforces the reactive streams protocol. For instance if you have several threads competing to send items, then items will still be emitted serially by one of the threads rather than concurrently.","title":"Creating using the general-purpose Tube API"},{"location":"quick-start/#helpers","text":"Mutiny Zero offers a few helpers for commonly-needed tasks, but without the intention of becoming a full-fledge reactive programming API. Introducing new helpers will always be done carefully by observing real world implementation patterns.","title":"Helpers"},{"location":"quick-start/#completionstage-helpers","text":"The AsyncHelpers class offers a few helpers to simplify developing against the CompletionStage , especially before Java 11. failedFuture creates a CompletionStage that has already failed. applyExceptionally applies a function to map a failure Throwable to another Throwable . composeExceptionally applies a function to compose a failure Throwable to another CompletionStage .","title":"CompletionStage helpers"},{"location":"quick-start/#publisher-helpers","text":"More often than not we need a little help when dealing with a Publisher . collectToList assembles all items from a Publisher to a CompletionStage<List> . map returns a Publisher that applies a function to all items from the original Publisher .","title":"Publisher helpers"}]}